package cope.nebula.client.feature.module.exploit;

import cope.nebula.asm.mixins.network.packet.s2c.ISPacketPlayerPosLook;
import cope.nebula.client.events.MotionEvent;
import cope.nebula.client.events.MotionUpdateEvent;
import cope.nebula.client.events.MotionUpdateEvent.Era;
import cope.nebula.client.events.PacketEvent;
import cope.nebula.client.feature.module.Module;
import cope.nebula.client.feature.module.ModuleCategory;
import cope.nebula.client.value.Value;
import cope.nebula.util.internal.math.MathUtil;
import cope.nebula.util.internal.math.Vec2d;
import cope.nebula.util.internal.timing.Stopwatch;
import cope.nebula.util.world.BlockUtil;
import cope.nebula.util.world.entity.player.MotionUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.PlayerSPPushOutOfBlocksEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class PacketFly extends Module {
    public PacketFly() {
        super("PacketFly", ModuleCategory.EXPLOIT, "Makes you fly with packets");
    }

    public static final Value<Bounds> bounds = new Value<>("Bounds", Bounds.NEGATIVE);
    public static final Value<Phase> phase = new Value<>("Phase", Phase.NCP);
    public static final Value<Double> factor = new Value<>("Factor", 1.0, 0.1, 5.0);
    public static final Value<Boolean> antiKick = new Value<>("AntiKick", true);

    private final Map<Integer, Stopwatch> teleports = new ConcurrentHashMap<>();
    private int teleportId = 0;

    @Override
    public String getDisplayInfo() {
        return String.valueOf(factor.getValue());
    }

    @Override
    protected void onDeactivated() {
        teleports.clear();
        teleportId = 0;

        if (!nullCheck()) {
            mc.player.noClip = false;
        }
    }

    @Override
    public void onTick() {
        teleports.forEach((id, stopwatch) -> {
            if (stopwatch.passedMs(100L)) {
                mc.player.connection.sendPacket(new CPacketConfirmTeleport(id));
                teleports.remove(id);
            }
        });
    }

    @SubscribeEvent
    public void onMotion(MotionEvent event) {
        if (!phase.getValue().equals(Phase.NONE)) {
            mc.player.noClip = true;
        }

        event.setX(mc.player.motionX);
        event.setY(mc.player.motionY);
        event.setZ(mc.player.motionZ);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onMotionUpdate(MotionUpdateEvent event) {
        if (event.getEra().equals(Era.PRE)) {
            mc.player.setVelocity(0.0, 0.0, 0.0);

            double speed = factor.getValue() / 10.0;
            if (BlockUtil.isInBlock()) {
                speed /= 3.0;
            }

            Vec2d motion = new Vec2d(0.0, 0.0);
            if (MotionUtil.isMoving()) {
                motion = MotionUtil.strafe(speed);
            }

            double motionY = mc.player.motionY;
            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                if (mc.player.ticksExisted % 10 == 0) {
                    motionY -= 0.001;
                } else {
                    motionY += 0.0255;
                }
            } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                motionY -= 0.02;
            } else if (antiKick.getValue()) {
                if (!MotionUtil.isMoving() && !BlockUtil.isInBlock()) {
                    if (mc.player.ticksExisted % 4 == 0) {
                        motionY = -0.0475;
                    } else {
                        motionY = -0.0345;
                    }
                }
            }

            mc.player.motionX = motion.getX();
            mc.player.motionY = motionY;
            mc.player.motionZ = motion.getZ();

            mc.player.setVelocity(mc.player.motionX, motionY, mc.player.motionZ);
            sendMovementPackets(mc.player.getPositionVector(), true);
        }
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook packet = event.getPacket();

            teleports.put(packet.getTeleportId(), new Stopwatch().resetTime());
            teleportId = packet.getTeleportId();

            ((ISPacketPlayerPosLook) packet).setYaw(mc.player.rotationYaw);
            ((ISPacketPlayerPosLook) packet).setPitch(mc.player.rotationPitch);
        }
    }

    @SubscribeEvent
    public void onPushOutOfBlocks(PlayerSPPushOutOfBlocksEvent event) {
        event.setCanceled(!phase.getValue().equals(Phase.NONE));
    }

    /**
     * Sends all movement packets
     * @param vec the position in a vector
     * @param sendBounds if to send a bounds packet
     */
    private void sendMovementPackets(Vec3d vec, boolean sendBounds) {
        sendPacket(vec);
        if (sendBounds && !bounds.getValue().equals(Bounds.NONE)) {
            sendBounds(vec);
        }
    }

    private void sendBounds(Vec3d vec) {
        sendPacket(getOutOfBoundsVec(vec));
    }

    /**
     * Sends a movement packet along with a teleport confirm packet with tpId + 1
     * @param vec the position in a vector
     */
    private void sendPacket(Vec3d vec) {
        mc.player.connection.sendPacket(new Position(vec.x, vec.y, vec.z, mc.player.onGround));
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId++));
        teleports.put(teleportId, new Stopwatch().resetTime());
    }

    /**
     * Gets the out-of-bounds packet offsets
     * @param vec The original position in a Vec3d
     * @return the modified bounds vec
     */
    private Vec3d getOutOfBoundsVec(Vec3d vec) {
        if (!bounds.getValue().equals(Bounds.NONE)) {
            if (BlockUtil.isInBlock() && phase.getValue().equals(Phase.NCP)) {
                return vec.add(0.0, 101.0, 0.0);
            }

            switch (bounds.getValue()) {
                case NEGATIVE: {
                    vec = new Vec3d(vec.x, -1377.69, vec.z);
                    break;
                }

                case POSITIVE: {
                    vec = new Vec3d(vec.x, 1377.69, vec.z);
                    break;
                }

                case PRESERVE: {
                    vec = vec.add(MathUtil.random(-1000, 1000), 0.0, MathUtil.random(-1000, 1000));
                    break;
                }

                case RANDOM: {
                    vec = new Vec3d(vec.x, MathUtil.random(-1337.69, 1377.69), vec.z);
                    break;
                }
            }
        }

        return vec;
    }

    public enum Bounds {
        NEGATIVE, POSITIVE, PRESERVE, RANDOM, NONE
    }

    public enum Phase {
        NONE, VANILLA, NCP
    }
}
