package cope.nebula.client.feature.module.exploit;

import cope.nebula.asm.mixins.network.INetHandlerPlayClient;
import cope.nebula.asm.mixins.network.packet.s2c.ISPacketPlayerPosLook;
import cope.nebula.client.events.MotionEvent;
import cope.nebula.client.events.PacketEvent;
import cope.nebula.client.feature.module.Module;
import cope.nebula.client.feature.module.ModuleCategory;
import cope.nebula.client.value.Value;
import cope.nebula.util.internal.math.MathUtil;
import cope.nebula.util.internal.math.Vec2d;
import cope.nebula.util.internal.timing.Stopwatch;
import cope.nebula.util.world.BlockUtil;
import cope.nebula.util.world.entity.player.MotionUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.PlayerSPPushOutOfBlocksEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class PacketFly extends Module {
    public PacketFly() {
        super("PacketFly", ModuleCategory.EXPLOIT, "Makes you fly with packets");
    }

    public static final Value<Mode> mode = new Value<>("Mode", Mode.SETBACK);
    public static final Value<Integer> factor = new Value<>("Factor", 1, 1, 5);
    public static final Value<Double> speed = new Value<>("Speed", 1.5, 0.1, 5.0);
    public static final Value<Phasing> phasing = new Value<>("Phasing", Phasing.VANILLA);
    public static final Value<Bounds> bounds = new Value<>("Bounds", Bounds.NEGATIVE);
    public static final Value<Boolean> antiKick = new Value<>("AntiKick", true);

    private final Map<Integer, Stopwatch> teleports = new ConcurrentHashMap<>();
    private int tpId = -1;

    @Override
    protected void onDeactivated() {
        teleports.clear();
        tpId = -1;

        if (!nullCheck()) {

            // stop us from moving cause sometimes we'll lagback
            mc.player.setVelocity(0.0, 0.0, 0.0);
        }
    }

    @Override
    public void onUpdate() {
        teleports.forEach((id, stopwatch) -> {
            if (stopwatch.passedMs(50L)) {
                mc.player.connection.sendPacket(new CPacketConfirmTeleport(id));
                teleports.remove(id);
            }
        });

        double motionX = 0.0;
        double motionY = 0.0;
        double motionZ = 0.0;

        if (mc.gameSettings.keyBindJump.isKeyDown()) {
            motionY = 0.06;
        } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            motionY = -0.058;
        } else if (antiKick.getValue()) {
            if (!MotionUtil.isMoving() && !BlockUtil.isInBlock()) {
                if (mc.player.ticksExisted % 10 == 0) {
                    motionY = -0.045;
                } else {
                    motionY = -0.0235;
                }
            }
        }

        if (MotionUtil.isMoving()) {
            double moveSpeed = speed.getValue() / 10.0;
            if (BlockUtil.isInBlock() && phasing.getValue().equals(Phasing.NCP)) {
                moveSpeed /= 3.0;
            }

            Vec2d motion = MotionUtil.strafe(moveSpeed);

            motionX = motion.getX();
            motionZ = motion.getZ();
        }

        switch (mode.getValue()) {
            case FAST:
            case SETBACK: {
                mc.player.setVelocity(motionX, motionY, motionZ);
                sendMovementPackets(motionX, motionY, motionZ, mode.getValue().equals(Mode.FAST));
                break;
            }

            case FACTOR: {
                for (int i = 0; i < factor.getValue(); ++i) {
                    mc.player.setVelocity(motionX * i, motionY, motionZ * i);
                    sendMovementPackets(motionX * i, motionY, motionZ * i, true);
                }
                break;
            }
        }
    }

    @SubscribeEvent
    public void onMotion(MotionEvent event) {
        event.setX(mc.player.motionX);
        event.setY(mc.player.motionY);
        event.setZ(mc.player.motionZ);

        if (!phasing.getValue().equals(Phasing.NONE)) {
            mc.player.noClip = true;
        }
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook packet = event.getPacket();

            teleports.put(packet.getTeleportId(), new Stopwatch().resetTime());

            ((ISPacketPlayerPosLook) packet).setYaw(mc.player.rotationYaw);
            ((ISPacketPlayerPosLook) packet).setPitch(mc.player.rotationPitch);

            if (((INetHandlerPlayClient) mc.player.connection).isDoneLoadingTerrain()) {
                if (teleports.containsKey(packet.getTeleportId()) && !mode.getValue().equals(Mode.SETBACK)) {
                    // event.setCanceled(true);
                    teleports.remove(packet.getTeleportId());
                }
            }

            tpId = packet.getTeleportId();
        }
    }

    @SubscribeEvent
    public void onPushOutOfBlocks(PlayerSPPushOutOfBlocksEvent event) {
        if (event.getEntityPlayer() != null && event.getEntityPlayer().equals(mc.player)) {
            event.setCanceled(true);
        }
    }

    private void sendMovementPackets(double motionX, double motionY, double motionZ, boolean confirmTp) {
        if (confirmTp) {
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpId++));
            teleports.put(tpId, new Stopwatch().resetTime());
        }

        Vec3d vec = new Vec3d(mc.player.posX, mc.player.getEntityBoundingBox().minY, mc.player.posZ).add(motionX, motionY, motionZ);
        mc.player.connection.sendPacket(new Position(vec.x, vec.y, vec.z, mc.player.onGround));

        Vec3d boundsVec = bounds.getValue().getModifier(vec);
        mc.player.connection.sendPacket(new Position(boundsVec.x, boundsVec.y, boundsVec.z, mc.player.onGround));
    }

    public enum Mode {
        /**
         * sends a confirmation tp packet with pos packet
         */
        FAST,

        /**
         * does not send a confirmation tp packet with pos packet
         */
        SETBACK,

        /**
         * uses a loop to go faster vroom
         */
        FACTOR
    }

    public enum Phasing {
        /**
         * does not handle phasing into blocks
         */
        NONE,

        /**
         * handles vanilla phasing into blocks (noClip = true)
         */
        VANILLA,

        /**
         * uses funny NCP phase packet value to phase (idk mane)
         */
        NCP
    }

    public enum Bounds {

        /**
         * Does not send a modified bounds packet
         */
        NONE(null),

        /**
         * Sends an out-of-bounds negative y packet
         */
        NEGATIVE((vec) ->
                vec.add(0.0, -1337.69, 0.0)),

        /**
         * Sends an out-of-bounds positive y packet
         */
        POSITIVE((vec) ->
                vec.add(0.0, 1337.69, 0.0)),

        /**
         * Sends all x, y, and z invalid position values
         */
        PRESERVE((vec) ->
                vec.add(MathUtil.random(-1.00000, 1.0000), 1.0, MathUtil.random(-1.00000, 1.0000)));

        private final BoundsModifier modifier;
        Bounds(BoundsModifier modifier) {
            this.modifier = modifier;
        }

        public Vec3d getModifier(Vec3d vec) {
            return modifier == null ? vec : modifier.modify(vec);
        }
    }

    @FunctionalInterface
    public interface BoundsModifier {
        /**
         * Modifies a vector for bounds packets
         * @param vec the vector to modify
         * @return the modified vector
         */
        Vec3d modify(Vec3d vec);
    }
}
